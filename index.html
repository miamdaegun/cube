<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D íšŒì „ ì •ìœ¡ë©´ì²´</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            perspective: 1000px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .container {
            width: 200px;
            height: 200px;
            position: relative;
            transform-style: preserve-3d;
            cursor: grab;
        }

        .container:active {
            cursor: grabbing;
        }

        .cube {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
        }

        .face {
            position: absolute;
            width: 200px;
            height: 200px;
            background: rgba(100, 100, 100, 0.8);
            border: 2px solid rgba(80, 80, 80, 0.5);
            box-shadow: inset 0 0 60px rgba(0, 0, 0, 0.3);
        }

        .front {
            transform: rotateY(0deg) translateZ(100px);
        }

        .back {
            transform: rotateY(180deg) translateZ(100px);
        }

        .right {
            transform: rotateY(90deg) translateZ(100px);
        }

        .left {
            transform: rotateY(-90deg) translateZ(100px);
        }

        .top {
            transform: rotateX(90deg) translateZ(100px);
        }

        .bottom {
            transform: rotateX(-90deg) translateZ(100px);
        }

        .instructions {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 30px;
            border-radius: 10px;
            font-family: 'Arial', sans-serif;
            color: #333;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body>
    <div class="instructions">
        ğŸ–±ï¸ ì •ìœ¡ë©´ì²´ë¥¼ ë“œë˜ê·¸í•˜ì—¬ íšŒì „ì‹œì¼œë³´ì„¸ìš”!
    </div>

    <div class="container" id="container">
        <div class="cube" id="cube">
            <div class="face front"></div>
            <div class="face back"></div>
            <div class="face right"></div>
            <div class="face left"></div>
            <div class="face top"></div>
            <div class="face bottom"></div>
        </div>
    </div>

    <script>
        const container = document.getElementById('container');
        const cube = document.getElementById('cube');
        
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // ì¿¼í„°ë‹ˆì–¸ìœ¼ë¡œ íšŒì „ ìƒíƒœ ì €ì¥
        let rotation = { w: 1, x: 0, y: 0, z: 0 };
        let velocity = { w: 1, x: 0, y: 0, z: 0 };
        let velocityResetTimer = null;

        // ì¿¼í„°ë‹ˆì–¸ ê³±ì…ˆ
        function multiplyQuaternions(q1, q2) {
            return {
                w: q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
                x: q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
                y: q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
                z: q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w
            };
        }

        // ì¿¼í„°ë‹ˆì–¸ ì •ê·œí™”
        function normalizeQuaternion(q) {
            const len = Math.sqrt(q.w * q.w + q.x * q.x + q.y * q.y + q.z * q.z);
            if (len === 0) return { w: 1, x: 0, y: 0, z: 0 };
            return {
                w: q.w / len,
                x: q.x / len,
                y: q.y / len,
                z: q.z / len
            };
        }

        // ì¿¼í„°ë‹ˆì–¸ì„ íšŒì „ í–‰ë ¬ë¡œ ë³€í™˜
        function quaternionToMatrix(q) {
            const { w, x, y, z } = q;
            
            const xx = x * x, yy = y * y, zz = z * z;
            const xy = x * y, xz = x * z, yz = y * z;
            const wx = w * x, wy = w * y, wz = w * z;
            
            return `matrix3d(
                ${1 - 2 * (yy + zz)}, ${2 * (xy + wz)}, ${2 * (xz - wy)}, 0,
                ${2 * (xy - wz)}, ${1 - 2 * (xx + zz)}, ${2 * (yz + wx)}, 0,
                ${2 * (xz + wy)}, ${2 * (yz - wx)}, ${1 - 2 * (xx + yy)}, 0,
                0, 0, 0, 1
            )`;
        }

        // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ arcball êµ¬ ìœ„ì˜ 3D ì ìœ¼ë¡œ ë³€í™˜
        function getArcballVector(x, y) {
            const rect = container.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const radius = Math.min(rect.width, rect.height) / 2;

            // ì •ê·œí™”ëœ ì¢Œí‘œ - ì˜ì—­ ì œí•œ ì—†ìŒ
            const px = (x - centerX) / radius;
            const py = (centerY - y) / radius; // Yì¶• ë°˜ì „

            const lengthSquared = px * px + py * py;

            if (lengthSquared <= 1) {
                // êµ¬ í‘œë©´ ìœ„ì˜ ì 
                return {
                    x: px,
                    y: py,
                    z: Math.sqrt(1 - lengthSquared)
                };
            } else {
                // êµ¬ ë°”ê¹¥ - í‰ë©´ì— íˆ¬ì˜ (ë¬´ì œí•œ)
                const length = Math.sqrt(lengthSquared);
                return {
                    x: px / length,
                    y: py / length,
                    z: 0
                };
            }
        }

        // ë‘ ë²¡í„°ë¡œë¶€í„° íšŒì „ ì¿¼í„°ë‹ˆì–¸ ìƒì„± (ìµœëŒ€ íšŒì „ ì†ë„ ì œí•œ ì¶”ê°€)
        function getRotationQuaternion(v1, v2) {
            // ì™¸ì ìœ¼ë¡œ íšŒì „ ì¶• ê³„ì‚°
            const axis = {
                x: v1.y * v2.z - v1.z * v2.y,
                y: v1.z * v2.x - v1.x * v2.z,
                z: v1.x * v2.y - v1.y * v2.x
            };

            // ë‚´ì ìœ¼ë¡œ íšŒì „ ê°ë„ ê³„ì‚°
            const dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
            
            // ìµœëŒ€ íšŒì „ ê°ë„ ì œí•œ (ë¼ë””ì•ˆ) - 0.025ë¡œ ê°ì†Œ
            const maxAngle = 0.025; // ì•½ 1.4ë„
            const angle = Math.acos(Math.max(-1, Math.min(1, dot)));
            const clampedAngle = Math.min(angle, maxAngle);
            
            // ì œí•œëœ ê°ë„ë¡œ ì¿¼í„°ë‹ˆì–¸ ìƒì„±
            const halfAngle = clampedAngle / 2;
            const axisLength = Math.sqrt(axis.x * axis.x + axis.y * axis.y + axis.z * axis.z);
            
            if (axisLength < 0.0001) {
                return { w: 1, x: 0, y: 0, z: 0 };
            }
            
            const sinHalfAngle = Math.sin(halfAngle);
            return normalizeQuaternion({
                w: Math.cos(halfAngle),
                x: (axis.x / axisLength) * sinHalfAngle,
                y: (axis.y / axisLength) * sinHalfAngle,
                z: (axis.z / axisLength) * sinHalfAngle
            });
        }

        // ê¸°ë³¸ ë“œë˜ê·¸ ë™ì‘ ë°©ì§€
        container.addEventListener('dragstart', (e) => {
            e.preventDefault();
        });

        container.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            velocity = { w: 1, x: 0, y: 0, z: 0 };
            
            if (velocityResetTimer) {
                clearTimeout(velocityResetTimer);
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const currentMouseX = e.clientX;
            const currentMouseY = e.clientY;

            // ì´ì „ ë° í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ arcball ë²¡í„°ë¡œ ë³€í™˜
            const v1 = getArcballVector(lastMouseX, lastMouseY);
            const v2 = getArcballVector(currentMouseX, currentMouseY);

            // íšŒì „ ì¿¼í„°ë‹ˆì–¸ ê³„ì‚°
            const deltaRotation = getRotationQuaternion(v1, v2);
            
            // í˜„ì¬ íšŒì „ì— ì ìš©
            rotation = multiplyQuaternions(deltaRotation, rotation);
            rotation = normalizeQuaternion(rotation);

            // ì†ë„ ëˆ„ì  - ë” ì²œì²œíˆ ëˆ„ì ë˜ë„ë¡ ê°ì†Œ
            const dampedDelta = {
                w: deltaRotation.w + (1 - deltaRotation.w) * 0.7,  // íšŒì „ëŸ‰ 30%ë§Œ ì ìš©
                x: deltaRotation.x * 0.3,
                y: deltaRotation.y * 0.3,
                z: deltaRotation.z * 0.3
            };
            velocity = multiplyQuaternions(normalizeQuaternion(dampedDelta), velocity);
            velocity = normalizeQuaternion(velocity);

            cube.style.transform = quaternionToMatrix(rotation);

            lastMouseX = currentMouseX;
            lastMouseY = currentMouseY;

            if (velocityResetTimer) {
                clearTimeout(velocityResetTimer);
            }

            velocityResetTimer = setTimeout(() => {
                if (isDragging) {
                    velocity = { w: 1, x: 0, y: 0, z: 0 };
                }
            }, 100);
        });

        document.addEventListener('mouseup', () => {
            if (!isDragging) return;
            
            isDragging = false;

            if (velocityResetTimer) {
                clearTimeout(velocityResetTimer);
                velocityResetTimer = null;
            }

            // ê´€ì„± íš¨ê³¼
            let currentVelocity = { ...velocity };
            
            const animate = () => {
                // ì¿¼í„°ë‹ˆì–¸ì˜ ê°ë„ ì„±ë¶„ ê³„ì‚°
                const angle = 2 * Math.acos(Math.max(-1, Math.min(1, currentVelocity.w)));
                
                if (angle > 0.001) {
                    rotation = multiplyQuaternions(currentVelocity, rotation);
                    rotation = normalizeQuaternion(rotation);
                    cube.style.transform = quaternionToMatrix(rotation);
                    
                    // ì†ë„ ê°ì‡  - íšŒì „ ê°ë„ë¥¼ ì¤„ì„
                    const decay = 0.97;
                    const halfAngle = angle * decay / 2;
                    const sinHalfAngle = Math.sin(halfAngle);
                    const axisLength = Math.sqrt(currentVelocity.x * currentVelocity.x + 
                                                  currentVelocity.y * currentVelocity.y + 
                                                  currentVelocity.z * currentVelocity.z);
                    
                    if (axisLength > 0.0001) {
                        currentVelocity = {
                            w: Math.cos(halfAngle),
                            x: (currentVelocity.x / axisLength) * sinHalfAngle,
                            y: (currentVelocity.y / axisLength) * sinHalfAngle,
                            z: (currentVelocity.z / axisLength) * sinHalfAngle
                        };
                    } else {
                        currentVelocity = { w: 1, x: 0, y: 0, z: 0 };
                    }
                    
                    requestAnimationFrame(animate);
                }
            };
            
            animate();
        });

        // í„°ì¹˜ ì´ë²¤íŠ¸ ì§€ì›
        container.addEventListener('touchstart', (e) => {
            isDragging = true;
            lastMouseX = e.touches[0].clientX;
            lastMouseY = e.touches[0].clientY;
            velocity = { w: 1, x: 0, y: 0, z: 0 };
        });

        document.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            e.preventDefault();

            const currentMouseX = e.touches[0].clientX;
            const currentMouseY = e.touches[0].clientY;

            const v1 = getArcballVector(lastMouseX, lastMouseY);
            const v2 = getArcballVector(currentMouseX, currentMouseY);

            const deltaRotation = getRotationQuaternion(v1, v2);
            
            rotation = multiplyQuaternions(deltaRotation, rotation);
            rotation = normalizeQuaternion(rotation);

            // ì†ë„ ëˆ„ì  - ê°ì†Œëœ ì†ë„
            const dampedDelta = {
                w: deltaRotation.w + (1 - deltaRotation.w) * 0.7,
                x: deltaRotation.x * 0.3,
                y: deltaRotation.y * 0.3,
                z: deltaRotation.z * 0.3
            };
            velocity = multiplyQuaternions(normalizeQuaternion(dampedDelta), velocity);
            velocity = normalizeQuaternion(velocity);

            cube.style.transform = quaternionToMatrix(rotation);

            lastMouseX = currentMouseX;
            lastMouseY = currentMouseY;
        });

        document.addEventListener('touchend', () => {
            if (!isDragging) return;
            
            isDragging = false;

            let currentVelocity = { ...velocity };
            
            const animate = () => {
                const angle = 2 * Math.acos(Math.max(-1, Math.min(1, currentVelocity.w)));
                
                if (angle > 0.001) {
                    rotation = multiplyQuaternions(currentVelocity, rotation);
                    rotation = normalizeQuaternion(rotation);
                    cube.style.transform = quaternionToMatrix(rotation);
                    
                    const decay = 0.97;
                    const halfAngle = angle * decay / 2;
                    const sinHalfAngle = Math.sin(halfAngle);
                    const axisLength = Math.sqrt(currentVelocity.x * currentVelocity.x + 
                                                  currentVelocity.y * currentVelocity.y + 
                                                  currentVelocity.z * currentVelocity.z);
                    
                    if (axisLength > 0.0001) {
                        currentVelocity = {
                            w: Math.cos(halfAngle),
                            x: (currentVelocity.x / axisLength) * sinHalfAngle,
                            y: (currentVelocity.y / axisLength) * sinHalfAngle,
                            z: (currentVelocity.z / axisLength) * sinHalfAngle
                        };
                    } else {
                        currentVelocity = { w: 1, x: 0, y: 0, z: 0 };
                    }
                    
                    requestAnimationFrame(animate);
                }
            };
            
            animate();
        });
    </script>
</body>
</html>
